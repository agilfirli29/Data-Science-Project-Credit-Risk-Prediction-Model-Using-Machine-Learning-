# -*- coding: utf-8 -*-
"""Final Task_ID/X Partners_Data Scientist_Agil Firli Gunawan

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jRFpVwrdznYyI01ui-eJphmVi5yHxGHq

# **Business Understanding**

Perusahaan pemberi pinjaman (multifinance) menghadapi tantangan besar dalam **mengelola risiko kredit**. Risiko kredit muncul ketika peminjam tidak mampu membayar kembali pinjaman sesuai jadwal. Jika penilaian kelayakan kredit kurang akurat, maka akan berdampak pada:

- **Kerugian finansial** karena meningkatnya gagal bayar (default).  
- **Turunnya profitabilitas** akibat keputusan persetujuan pinjaman yang salah.  
- **Meningkatnya risiko operasional & reputasi** bila banyak pinjaman bermasalah.  

Untuk itu, perusahaan ingin meningkatkan **akurasi penilaian risiko kredit** agar dapat:  
1. Membedakan debitur **berisiko tinggi** dan **rendah** dengan lebih tepat.  
2. Mengurangi potensi kerugian akibat gagal bayar.  
3. Mengoptimalkan portofolio pinjaman sehingga lebih sehat.  
4. Membantu pengambilan keputusan berbasis data.  


## Tujuan Analisis
Sebagai Data Scientist di ID/X Partners, tujuan utama proyek ini adalah membangun **model machine learning untuk memprediksi risiko kredit** berdasarkan data historis pinjaman (approved & rejected).  

Model ini akan membantu perusahaan untuk:  
- Mengidentifikasi pola & faktor utama yang memengaruhi risiko kredit.  
- Memberikan prediksi apakah calon peminjam termasuk kategori **high risk** atau **low risk**.  
- Mendukung strategi manajemen risiko kredit dengan pendekatan berbasis data.  

## Tahapan Proyek
1. **Data Understanding** – memahami struktur dataset, variabel, dan kualitas data.  
2. **Exploratory Data Analysis (EDA)** – mengeksplorasi distribusi, korelasi, dan pola data dengan melakukan analisis univariat , bivariat dan Multivariate.
3. **Data Preparation** – pembersihan data, penanganan missing values, encoding, dan scaling.  
4. **Feature Engineering** – membuat/transformasi fitur baru agar lebih representatif.  
5. **Data Modeling & Evaluation** – membangun model machine learning dan evaluasi performa dengan metrik (seperti AUC, F1-score, accuracy dan lainya).  

**Output Akhir**: Model prediksi risiko kredit yang dapat digunakan sebagai **credit scoring system** untuk membantu perusahaan mengambil keputusan persetujuan pinjaman secara lebih akurat dan optimal.
"""

#Library
import pandas as pd
import numpy as np
import matplotlib
import matplotlib.gridspec as gridspec
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import OneHotEncoder
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, classification_report
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer
from sklearn.metrics import roc_curve, auc, confusion_matrix, ConfusionMatrixDisplay

"""# **Data Understanding**"""

# Load dataset
df = pd.read_csv("loan_data.csv")
df.head(10)

df.info()

"""## **Mengidentifikasi Data**

Dataset **loan_data.csv** memiliki **466.285 baris** dan **74 kolom**.  
Berikut penjelasan arti setiap kolom:

1. **id** : ID unik untuk pinjaman.  
2. **member_id** : ID unik untuk anggota nasabah.  
3. **loan_amnt** : Jumlah pinjaman yang diajukan peminjam.  
4. **funded_amnt** : Jumlah pinjaman yang disetujui oleh Lending Club.  
5. **funded_amnt_inv** : Jumlah pinjaman yang didanai oleh investor.  
6. **term** : Lama pinjaman (misalnya 36 bulan atau 60 bulan).  
7. **int_rate** : Tingkat bunga pinjaman.  
8. **installment** : Jumlah cicilan bulanan yang harus dibayar peminjam.  
9. **grade** : Kategori risiko pinjaman (A sampai G).  
10. **sub_grade** : Subkategori risiko pinjaman (misal A1, A2, … G5).  
11. **emp_title** : Jabatan pekerjaan peminjam.  
12. **emp_length** : Lama bekerja (dalam tahun).  
13. **home_ownership** : Status kepemilikan rumah (RENT, OWN, MORTGAGE, OTHER).  
14. **annual_inc** : Pendapatan tahunan yang dilaporkan peminjam.  
15. **verification_status** : Status verifikasi pendapatan (Verified, Source Verified, Not Verified).  
16. **issue_d** : Bulan/tahun pinjaman diterbitkan.  
17. **loan_status** : Status pinjaman saat ini (misal: Current, Fully Paid, Charged Off).  
18. **pymnt_plan** : Indikator apakah ada rencana pembayaran khusus (y/n).  
19. **url** : URL detail pinjaman (sudah deprecated).  
20. **desc** : Deskripsi pinjaman dari peminjam.  
21. **purpose** : Tujuan pinjaman (misal: debt_consolidation, credit_card, home_improvement).  
22. **title** : Judul pinjaman.  
23. **zip_code** : 3 digit pertama kode pos peminjam.  
24. **addr_state** : Negara bagian tempat peminjam tinggal.  
25. **dti** : Debt-to-Income ratio (rasio total utang terhadap pendapatan).  
26. **delinq_2yrs** : Jumlah keterlambatan pembayaran (30+ hari) dalam 2 tahun terakhir.  
27. **earliest_cr_line** : Tahun/bulan pembukaan akun kredit pertama.  
28. **inq_last_6mths** : Jumlah permintaan kredit dalam 6 bulan terakhir.  
29. **mths_since_last_delinq** : Jumlah bulan sejak keterlambatan terakhir.  
30. **mths_since_last_record** : Jumlah bulan sejak catatan publik terakhir (misal kebangkrutan).  
31. **open_acc** : Jumlah akun kredit yang masih aktif.  
32. **pub_rec** : Jumlah catatan publik negatif (misal kebangkrutan).  
33. **revol_bal** : Saldo kredit bergulir (revolving balance).  
34. **revol_util** : Persentase penggunaan kredit bergulir terhadap total kredit yang tersedia.  
35. **total_acc** : Jumlah total akun kredit peminjam.  
36. **initial_list_status** : Status daftar awal pinjaman (w = whole, f = fractional).  
37. **out_prncp** : Jumlah pokok pinjaman yang masih belum dibayar.  
38. **out_prncp_inv** : Jumlah pokok pinjaman yang belum dibayar oleh investor.  
39. **total_pymnt** : Total pembayaran yang diterima hingga saat ini.  
40. **total_pymnt_inv** : Total pembayaran yang diterima investor hingga saat ini.  
41. **total_rec_prncp** : Total pokok yang sudah dibayar.  
42. **total_rec_int** : Total bunga yang sudah dibayar.  
43. **total_rec_late_fee** : Total biaya keterlambatan yang sudah dibayar.  
44. **recoveries** : Total dana yang dipulihkan dari peminjam gagal bayar.  
45. **collection_recovery_fee** : Biaya penagihan.  
46. **last_pymnt_d** : Bulan/tahun pembayaran terakhir.  
47. **last_pymnt_amnt** : Jumlah pembayaran terakhir yang diterima.  
48. **next_pymnt_d** : Tanggal pembayaran berikutnya yang dijadwalkan.  
49. **last_credit_pull_d** : Bulan/tahun laporan kredit terakhir ditarik.  
50. **collections_12_mths_ex_med** : Jumlah koleksi dalam 12 bulan terakhir (tidak termasuk medis).  
51. **mths_since_last_major_derog** : Bulan sejak pelanggaran besar terakhir (90+ hari).  
52. **policy_code** : Kode kebijakan (1 = tersedia untuk umum).  
53. **application_type** : Jenis aplikasi (Individual / Joint).  
54. **annual_inc_joint** : Pendapatan tahunan gabungan (jika joint application).  
55. **dti_joint** : Debt-to-Income ratio gabungan (jika joint application).  
56. **verification_status_joint** : Status verifikasi pendapatan gabungan.  
57. **acc_now_delinq** : Jumlah akun yang saat ini dalam status gagal bayar.  
58. **tot_coll_amt** : Total jumlah utang dalam koleksi.  
59. **tot_cur_bal** : Total saldo berjalan dari semua akun.  
60. **open_acc_6m** : Jumlah akun kredit yang dibuka dalam 6 bulan terakhir.  
61. **open_il_6m** : Jumlah akun angsuran yang dibuka dalam 6 bulan terakhir.  
62. **open_il_12m** : Jumlah akun angsuran yang dibuka dalam 12 bulan terakhir.  
63. **open_il_24m** : Jumlah akun angsuran yang dibuka dalam 24 bulan terakhir.  
64. **mths_since_rcnt_il** : Bulan sejak akun angsuran terbaru dibuka.  
65. **total_bal_il** : Total saldo akun angsuran.  
66. **il_util** : Rasio saldo terhadap batas kredit pada akun angsuran.  
67. **open_rv_12m** : Jumlah akun revolving yang dibuka dalam 12 bulan terakhir.  
68. **open_rv_24m** : Jumlah akun revolving yang dibuka dalam 24 bulan terakhir.  
69. **max_bal_bc** : Saldo tertinggi pada akun kredit bergulir.  
70. **all_util** : Rasio saldo terhadap limit kredit di semua akun.  
71. **total_rev_hi_lim** : Total limit kredit revolving.  
72. **inq_fi** : Jumlah permintaan kredit finansial.  
73. **total_cu_tl** : Jumlah akun kredit berbasis usaha (trade lines).  
74. **inq_last_12m** : Jumlah permintaan kredit dalam 12 bulan terakhir.

## **Eksplorasi awal**
"""

#eksplorasi awal terhadap distribusi variabel
df['loan_status'].value_counts()

#Statistik Deskriptif
df.describe()

"""# **Exploratory Data Analysis**

## **Univariate Analysis**

Memahami distribusi tiap variabel
"""

num_cols = ['loan_amnt', 'int_rate', 'annual_inc', 'dti']
cat_cols = ['grade', 'home_ownership', 'purpose']

"""Agar analisis lebih fokus pada fitur utama yang berhubungan dengan risiko kredit dan komunikatif bagi audiens, sementara fitur lain akan dipertimbangkan saat feature selection & modeling."""

fig, axes = plt.subplots(2, 2, figsize=(14,10))

for ax, col in zip(axes.flatten(), num_cols):
    sns.histplot(df[col], kde=True, bins=30, ax=ax)
    ax.set_title(f'Distribusi {col}')
    ax.set_xlabel(col)
    ax.set_ylabel("Frequency")

plt.tight_layout()
plt.show()

fig = plt.figure(figsize=(14,8))
gs = gridspec.GridSpec(2, 2, height_ratios=[1, 1.2])

for ax, col, pos in zip(
    [plt.subplot(gs[0,0]), plt.subplot(gs[0,1]), plt.subplot(gs[1,:])],
    ['grade', 'home_ownership', 'purpose'],
    [(0,0), (0,1), (1,slice(None))]
):
    sns.countplot(data=df, x=col, order=df[col].value_counts().index, ax=ax)
    ax.set_title(f'Distribusi {col}')
    ax.tick_params(axis='x', rotation=30 if col!='purpose' else 45)

plt.tight_layout()
plt.show()

"""## **Bivariat Analysis**"""

#Numerik vs Target
num_cols = ['loan_amnt', 'int_rate', 'annual_inc', 'dti']

fig, axes = plt.subplots(2, 2, figsize=(14,10))

for ax, col in zip(axes.flatten(), num_cols):
    sns.boxplot(x='loan_status', y=col, data=df, ax=ax)
    ax.set_title(f'{col} vs Loan Status')
    ax.tick_params(axis='x', rotation=35)
plt.tight_layout()
plt.show()

#Kategorikal vs Target
cat_cols = ['grade', 'home_ownership', 'purpose']

fig, axes = plt.subplots(2, 2, figsize=(14,10))

for ax, col in zip(axes.flatten(), cat_cols):
    sns.countplot(x=col, hue='loan_status', data=df,
                  order=df[col].value_counts().index, ax=ax)
    ax.set_title(f'{col} vs Loan Status')
    ax.tick_params(axis='x', rotation=70)

for i in range(len(cat_cols), len(axes.flatten())):
    fig.delaxes(axes.flatten()[i])

plt.tight_layout()
plt.show()

"""## **Multivariate Analysis**
korelasi antara fitur-fitur
"""

plt.figure(figsize=(12,8))
corr = df[num_cols + ['loan_amnt', 'dti']].corr()  # subset numerik
sns.heatmap(corr, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Korelasi antar fitur numerik')
plt.show()

"""# **Data Preparation**

## **Menangani nilai yang hilang**
"""

print("Jumlah Missing Values sebelum ditangani:")
print(df.isnull().sum().sort_values(ascending=False).head(10))

# Imputasi contoh
df['emp_length'] = df['emp_length'].fillna(df['emp_length'].mode()[0])   # mode (kategorikal)
df['annual_inc'] = df['annual_inc'].fillna(df['annual_inc'].median())    # median (numerik)

# Drop kolom yang tidak relevan / terlalu banyak missing
df = df.drop(columns=['desc', 'url', 'member_id'], errors='ignore')

df.isna().sum()

"""## **Mengatasi outlier**"""

#Contoh winsorizing annual_inc)=
import numpy as np
q1 = df['annual_inc'].quantile(0.01)
q99 = df['annual_inc'].quantile(0.99)
df['annual_inc'] = np.clip(df['annual_inc'], q1, q99)

plt.figure(figsize=(10,4))
sns.boxplot(x=df['annual_inc'])
plt.title("Distribusi annual_inc setelah winsorizing")
plt.show()

"""## **Melakukan Encoding**"""

#Variabel kategorikal
from sklearn.preprocessing import LabelEncoder

cat_cols = ['grade', 'home_ownership', 'purpose', 'verification_status']
encoder = LabelEncoder()

for col in cat_cols:
    if col in df.columns:
        df[col] = encoder.fit_transform(df[col].astype(str))

df[cat_cols].head()

"""## **Melakukan scaling atau normalisasi**"""

# Scaling / Normalisasi fitur numerik
from sklearn.preprocessing import StandardScaler

num_cols = ['loan_amnt', 'int_rate', 'annual_inc', 'dti']
scaler = StandardScaler()
df[num_cols] = scaler.fit_transform(df[num_cols])

df[num_cols].describe().T

"""## **Membagi data menjadi train set dan test set.**"""

#Membagi data menjadi train set dan test set
from sklearn.model_selection import train_test_split

X = df.drop('loan_status', axis=1)  # fitur
y = df['loan_status']               # target

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

print("Shape data train:", X_train.shape)
print("Shape data test :", X_test.shape)

train_pct = len(X_train) / len(df) * 100
test_pct  = len(X_test) / len(df) * 100

print(f"Persentase train set: {train_pct:.2f}%")
print(f"Persentase test set : {test_pct:.2f}%")

"""Data berhasil dibagi menjadi train set sebanyak 373.028 baris (80%) dan test set sebanyak 93.257 baris (20%) dengan jumlah fitur 71 kolom. Pembagian data menggunakan stratify=y sehingga distribusi target (loan_status) tetap seimbang antara train dan test.

# **Feature Engginering**
"""

# Debt-to-Income Flag
df['high_dti'] = (df['dti'] > 40).astype(int)
print("kolom high_dti:")
print(df[['dti', 'high_dti']].head(), "\n")

# Log Transform Annual Income (aman dari nilai negatif)
df['log_annual_inc'] = np.log1p(df['annual_inc'].clip(lower=0))
print("kolom log_annual_inc:")
print(df[['annual_inc', 'log_annual_inc']].head(), "\n")

# Loan to Income Ratio
df['loan_income_ratio'] = df['loan_amnt'] / (df['annual_inc'] + 1)
print("kolom loan_income_ratio:")
print(df[['loan_amnt', 'annual_inc', 'loan_income_ratio']].head(), "\n")

# Employment Length Flag
if 'emp_length' in df.columns:
    df['emp_length_numeric'] = df['emp_length'].replace({'< 1 year': '0', '10\\+ years': '10', ' years': '', ' year': ''}, regex=True).astype(float)
    df['short_emp'] = (df['emp_length_numeric'] <= 1).astype(int)
    print("kolom short_emp:")
    print(df[['emp_length', 'emp_length_numeric', 'short_emp']].head())

# Pilih kolom kategorikal
cat_cols = ['grade', 'home_ownership', 'purpose', 'verification_status']
print("Kolom kategorikal:", cat_cols)

# One-Hot Encoding
encoder = OneHotEncoder(drop='first', sparse_output=False, handle_unknown='ignore')
encoded_cat = encoder.fit_transform(df[cat_cols])

# DataFrame hasil encoding
encoded_cat_df = pd.DataFrame(encoded_cat,
                              columns=encoder.get_feature_names_out(cat_cols),
                              index=df.index)

# Gabungkan kembali
df_encoded = pd.concat([df.drop(columns=cat_cols), encoded_cat_df], axis=1)

print("Shape data setelah encoding:", df_encoded.shape)
df_encoded.head()

"""# **Data Modelling + Evaluasi**"""

# Sampling data agar runtime lebih ringan karena spesifikasi perangkat saya kurang memadai
df_sample = df.sample(50000, random_state=42)

# Target
y = df_sample['loan_status'].apply(lambda x: 1 if x == "Charged Off" else 0)

# Pilih subset fitur
num_cols = ['loan_amnt', 'int_rate', 'annual_inc', 'dti']
cat_cols = ['grade', 'home_ownership']
X = df_sample[num_cols + cat_cols]

# Split data
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

# Preprocessing dengan Imputer
preprocessor = ColumnTransformer(
    transformers=[
        ('num', Pipeline(steps=[
            ('imputer', SimpleImputer(strategy='median')),   # isi NaN numerik dengan median
        ]), num_cols),

        ('cat', Pipeline(steps=[
            ('imputer', SimpleImputer(strategy='most_frequent')),  # isi NaN kategorikal dengan mode
            ('onehot', OneHotEncoder(handle_unknown='ignore'))
        ]), cat_cols)
    ]
)

# Inisialisasi model
models = {
    "Logistic Regression": LogisticRegression(max_iter=500, solver='liblinear'),
    "Random Forest": RandomForestClassifier(n_estimators=100, random_state=42),
    "XGBoost": XGBClassifier(use_label_encoder=False, eval_metric='logloss', random_state=42)
}

# Training & Evaluasi
results = []
for name, model in models.items():
    pipe = Pipeline(steps=[('preprocess', preprocessor),
                           ('model', model)])

    pipe.fit(X_train, y_train)
    y_pred = pipe.predict(X_test)
    y_prob = pipe.predict_proba(X_test)[:, 1]

    results.append({
        "Model": name,
        "Accuracy": accuracy_score(y_test, y_pred),
        "Precision": precision_score(y_test, y_pred),
        "Recall": recall_score(y_test, y_pred),
        "F1-Score": f1_score(y_test, y_pred),
        "ROC-AUC": roc_auc_score(y_test, y_prob)
    })

    print(f"\n{name} Classification Report:\n")
    print(classification_report(y_test, y_pred))

results_df = pd.DataFrame(results)
print("\n=== Hasil Perbandingan Model ===\n")
print(results_df)

# Cek Overfitting/Underfitting
print("\n=== Overfitting vs Underfitting ===\n")
for name, model in models.items():
    pipe = Pipeline(steps=[('preprocess', preprocessor),
                           ('model', model)])
    pipe.fit(X_train, y_train)
    print(f"{name} - Train: {pipe.score(X_train, y_train):.3f}, Test: {pipe.score(X_test, y_test):.3f}")

# ROC Curve
plt.figure(figsize=(8,6))

for name, model in models.items():
    pipe = Pipeline(steps=[
        ('preprocess', preprocessor),
        ('model', model)
    ])
    pipe.fit(X_train, y_train)
    y_prob = pipe.predict_proba(X_test)[:, 1]

    fpr, tpr, _ = roc_curve(y_test, y_prob)
    roc_auc = auc(fpr, tpr)
    plt.plot(fpr, tpr, label=f"{name} (AUC = {roc_auc:.2f})")

plt.plot([0,1],[0,1],'k--')
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("ROC Curve Perbandingan Model")
plt.legend()
plt.show()

# Confusion Matrix sejajar
fig, axes = plt.subplots(1, len(models), figsize=(15,5))

for ax, (name, model) in zip(axes, models.items()):
    pipe = Pipeline(steps=[
        ('preprocess', preprocessor),
        ('model', model)
    ])
    pipe.fit(X_train, y_train)
    y_pred = pipe.predict(X_test)

    cm = confusion_matrix(y_test, y_pred)
    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=pipe.classes_)
    disp.plot(cmap="Blues", ax=ax, colorbar=False)
    ax.set_title(f"Confusion Matrix - {name}")

plt.tight_layout()
plt.show()

"""# **Business Impact**

Pengembangan model machine learning dalam prediksi risiko kredit memberikan dampak bisnis yang signifikan bagi perusahaan multifinance. Dengan adanya model ini, perusahaan dapat lebih efektif dalam mendeteksi calon peminjam yang berpotensi gagal bayar, sehingga risiko kerugian akibat kredit macet dapat ditekan. Selain itu, keputusan persetujuan pinjaman menjadi lebih efisien karena tidak hanya mengandalkan analisis manual, melainkan didukung oleh sistem berbasis data yang lebih objektif. Hal ini memungkinkan perusahaan untuk merancang strategi bisnis yang lebih optimal, misalnya memberikan bunga lebih tinggi atau monitoring khusus untuk peminjam yang tergolong berisiko. Pada akhirnya, model ini berkontribusi dalam meningkatkan profitabilitas perusahaan dengan menjaga kualitas portofolio pinjaman.

Berdasarkan hasil evaluasi, model XGBoost menunjukkan performa terbaik dibandingkan Logistic Regression dan Random Forest. Dengan nilai ROC-AUC mencapai sekitar 0.86 dan F1-Score 0.76, model ini mampu memberikan keseimbangan yang baik antara kemampuan mendeteksi peminjam berisiko (recall) dan ketepatan prediksi (precision). Random Forest juga memberikan hasil yang cukup baik dengan ROC-AUC 0.84, sehingga dapat dijadikan alternatif model. Sementara itu, Logistic Regression tetap penting sebagai baseline yang sederhana dan mudah dipahami, meskipun performanya lebih rendah. Secara keseluruhan, penggunaan XGBoost sebagai model utama direkomendasikan karena dapat membantu perusahaan dalam mengurangi risiko kerugian kredit dan mengoptimalkan pengambilan keputusan bisnis.
"""